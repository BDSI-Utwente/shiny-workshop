---
title: Adaptive inputs
author: Karel Kroeze
affiliation: Behavioural Data Science incubator, Faculty of Behavioural, Management, and Social Sciences, University of Twente, Enschede, the Netherlands
format: html
server: shiny
---

## The problem

The goal of most shiny apps let the user interact with some dataset. We'll set up inputs to match 
the different variables in the dataset, perhaps to select a variable, filter on a column, and so forth.

Consider a simple app designed to query (old) billboard top 100 data. A first iteration might simply show a table of tracks.

```{r}
#| context: setup
#| include: false


library(shiny)
library(tidyverse)

``` 

```{r}
#| context: data

# example dataset
data("billboard")

# The billboard dataset is a textbook example of a 'wide' dataset, we use
# the example code from the `pivot_wider(...)` function to create a 'long'
# dataset containing one row for each track, for each week that it listed
# in the charts.
billboard_long <- billboard %>%
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    names_prefix = "wk",
    values_to = "rank",
    values_drop_na = TRUE
  ) %>% 
  mutate(week = as.numeric(week))
``` 

We can then let the user show the top 10 songs or artists in 1999-2000 (the data covers `r range(billboard$date.entered) %>% stringr::str_flatten(" to ")`). The shiny UI for this is simple: 

```{r}
#| echo: true

radioButtons("top_type", "Show top...", c("artists", "tracks"), inline = TRUE)
tableOutput("top_10")
```

With a simple `if` statement to select aggregate by track or artist, depending 
 on the selected input.

```r 
output$top_10 <- renderTable({
  # count weeks in ranking, then sort descending
  
  if (input$top_type == "artists") {
    weeks_in_ranking <- billboard_long %>% 
      count(artist)
  }
  if (input$top_type == "tracks") {
    weeks_in_ranking <- billboard_long %>%
      count(artist, track)
  }
  
  weeks_in_ranking %>% 
    arrange(-n) %>% 
    rename(`weeks` = n) %>% 
    head(10)
})
```
```{r}
#| echo: true
#| context: server

# NOTE: It's apparently not possible to echo the source code in server context chunks,
# so their contents are manually duplicated into a non-evaluated code section for display
# only, and the code that is actually run. 
# The following is the 'real' code, with duplicated code below. I've tried to keep 
# them perfectly synced, but some inaccuracies may have slipped in over time. 

output$top_10 <- renderTable({
  # count weeks in ranking, then sort descending
  
  if (input$top_type == "artists") {
    weeks_in_ranking <- billboard_long %>% 
      count(artist)
  }
  if (input$top_type == "tracks") {
    weeks_in_ranking <- billboard_long %>%
      count(artist, track)
  }
  
  weeks_in_ranking %>% 
    arrange(-n) %>% 
    rename(`weeks` = n) %>% 
    head(10)
})
```

This works great, because we know in advance which variables we have, and their number is rather limited. What happens if we have a dataset with dozens, if not hundreds, of variables? What happens if we want to let the user select values, not variables? 

Imagine that our manager requested that not only do we show the top artists and tracks, we also allow users to show a graph for how a song performed over time. We'll need a way to let the user select artists and tracks. We could theoretically go over the list of all artists and tracks and manually create an input with all these inputs, but the simpler option is to just derive the available options from the data. 

The UI is again relatively straightforward: 

```{r}
#| echo: true

selectInput("artist", "Choose an artist", billboard %>% distinct(artist))
selectInput("track", "Choose a track", billboard %>% distinct(track))
plotOutput("track_performance")
```

As is the server, we're again using user input to filter the data, which is then 
plotted in a simple line chart.

```r
output$track_performance <- renderPlot({
  # filter data with user choices
  billboard_long %>%
    filter(artist == input$artist, track == input$track) %>%
    ggplot(aes(x = week, y = rank, group = track)) +
    coord_cartesian(ylim = c(100, 1)) +
    geom_line()
})
```
```{r}
#| context: server

output$track_performance <- renderPlot({
  # filter data with user choices
  billboard_long %>%
    filter(artist == input$artist, track == input$track) %>%
    ggplot(aes(x = week, y = rank, group = track)) +
    coord_cartesian(ylim = c(100, 1)) +
    geom_line()
})
```

That's greatly simplified creating the artist and track selection, but we have a new problem: the list of tracks isn't synchronized with the selected artist. The default selected artist and track just happen to be a match, but if we select a track that wasn't by the selected artist, we just get a blank plot. 

Ideally, we'd like to update the available track choices based on the selected artist. We can do that by telling the server to look for changes in the selected artist, and then update the track selection input. This pattern is called an 'observer'. The code for the user interface is identical (though we've changed the input/output id's so they don't conflict with the previous example).

```{r}
#| echo: true

selectInput("artist_v2", "Choose an artist", billboard %>% distinct(artist))
selectInput("track_v2", "Choose a track", billboard %>% distinct(track))
plotOutput("track_performance_v2")
```

On the server side, we've added an observer to watch for changes in the selected artist, and update the list of tracks when needed. The code for the graphs is identical to the previous example (with the exception, again, of new id's).

```r
# create an 'observer' that triggers an action when it's inputs change.
# note that the name we give this observer is irrelevant, but I like to use 
# descriptive names following a "on_<subject>_<verb>" template.

on_artist_change <- observe({
  updateSelectInput(
    session,      # 'session' is an optional argument to the 'server(...)`
                  # function, and contains information on the client the server is
                  # talking to - as the server can have multiple users each with 
                  # their own 'copy' of the app at the same time.
    "track_v2",
    choices = billboard %>%                   # we update the available track choices 
      filter(artist == input$artist_v2) %>%   # by filtering by the selected artist.
      pull(track) %>%                         # Note that the selected track will auto-
      unique()                                # change, as whatever track was previously
  )                                           # selected will now no longer be valid. 
})

output$track_performance_v2 <- renderPlot({
  # filter data with user choices
  billboard_long %>%
    filter(artist == input$artist_v2, track == input$track_v2) %>%
    ggplot(aes(x = week, y = rank, group = track)) +
    coord_cartesian(ylim = c(100, 1)) +
    geom_line()
})
```
```{r}
#| context: server

# create an 'observer' that triggers an action when it's inputs change.
on_artist_change <- observe({
  #
  updateSelectInput(
    session,
    "track_v2",
    choices = billboard %>%
      filter(artist == input$artist_v2) %>%
      pull(track) %>% 
      unique()
  )
})

output$track_performance_v2 <- renderPlot({
  # filter data with user choices
  billboard_long %>%
    filter(artist == input$artist_v2, track == input$track_v2) %>%
    ggplot(aes(x = week, y = rank, group = track)) +
    coord_cartesian(ylim = c(100, 1)) +
    geom_line()
})
```

Now, whenever the artist changes, the list of tracks we can choose from changes with it. 

## dynamic UI

In the previous section, we updated the available choices for a ui element, but the basic UI elements stayed the same. But what if we want to add, remove, or change inputs or other UI elements dynamically? For example, what if for artists with only one track in the billboard data, 
we want to hide the track choice dropdown, and display only the track name instead? 

This is a simplified example, but we can accomplish this - and much, much more - using 
the `uiOutput` and `renderUI` functions. These functions allow us to define and update UI elements on the server, and use them as inputs just as if they were defined in the UI. 

```{r}
#| class-output: no-overflow-x
#| echo: true

# !! We had to wrap inputs in a 'div' element to avoid quarto creating a separate
# cell container # for each input/output and screwing up overflow on the dropdown 
# element(s). The extra div isn't necessary in a regular shiny app.
div(
  selectInput("artist_v3", "Choose an artist", billboard %>% distinct(artist)),
  uiOutput("track_v3_ui"),
  plotOutput("track_performance_v3")
)
```

While the UI is very similar, the server-side code is considerably more complex. Because we've meddled with the default flow of operations, we now have to manually handle some edge cases. For example, because we're hiding the track selection dropdown for artists with only one track in the billboards data, the selected track isn't automatically updated when a new artist is selected. This logic is handled with a reactive value and two observers at the top of the server code:

```r
# create a 'reactive' object that we can use to manually trigger track selection changes
selected_track <- reactiveVal()

# if a track is manually chosen, update the selected track.
on_track_changed <- observe({
  selected_track(input$track_v3)
})

# if the chosen artist changes, and only one track is available, set it as selected
# note that is there are multiple choices, we don't have to change the selected track,
# the selectInput widget will trigger a change event for us, and the `on_track_changed`
# observer we defined above will update the selected track.
on_artist_changed <- observe({
  .tracks <- billboard %>% 
    filter(artist == input$artist_v3) %>% 
    pull(track) %>%
    unique()
  
  if (length(.tracks) == 1) {
    selected_track(.tracks[1])
   }
})
```

The UI for track selection is either the `selectInput` function we've used before,
or a non-interactive label created with 'plain' HTML elements. 

```r
output$track_v3_ui <- renderUI({
  req(input$artist_v3)
  
  .tracks <- billboard %>% 
    filter(artist == input$artist_v3) %>% 
    pull(track) %>%
    unique()
  
  if (length(.tracks) == 1) {
    # If there's only one option, show a non-interactive text element with the 
    # track name
    return(
      # shiny provides 'wrapper' functions to create basic html elements. In this 
      # case, we use a div containing a label (less common or conflicting html tags
      # are accessible through the `tags` list) and a paragraph (`p`) element.
      # The paragraph has a grey text colour to visually clue the user in (even more)
      # that this value cannot be changed (it is 'disabled').
      # For more info on html elements or css styling, see your favourite search engine.
      div(
      tags$label("Selected track:"),
      p(.tracks, style = "color: darkgrey;")
    ))
  } else {
    # if we have multiple choices, we use the selectInput shiny widget. 
    # Note that the input we return is essentially identical to the input we 
    # used in the UI in the previous examples.
    return(selectInput("track_v3", label = "Choose a track...", choices = .tracks))
  }
})
```

Finally, the plot output is almost identical, but we now use the reactive value for
the selected track, rather than the user input directly.

```r
output$track_performance_v3 <- renderPlot({
  # only continue when a track is selected.
  req(selected_track())
  
  billboard_long %>% 
    filter(artist == input$artist_v3, track == selected_track()) %>% 
    ggplot(aes(x = week, y = rank, group = track)) +
    coord_cartesian(ylim = c(100, 1)) +
    geom_line()
})
```

```{r}
#| context: server

# create a 'reactive' object that we can use to manually trigger track selection changes
selected_track <- reactiveVal()

# if a track is manually chosen, update the selected track.
on_track_changed <- observe({
  selected_track(input$track_v3)
})

# if the chosen artist changes, and only one track is available, set it as selected
# note that is there are multiple choices, we don't have to change the selected track,
# the selectInput widget will trigger a change event for us, and the `on_track_changed`
# observer we defined above will update the selected track.
on_artist_changed <- observe({
  .tracks <- billboard %>% 
    filter(artist == input$artist_v3) %>% 
    pull(track) %>%
    unique()
  
  if (length(.tracks) == 1) {
    selected_track(.tracks[1])
   }
})

# the UI for track selection is created dynamically, based on if there is any choice to
# make for the user.
output$track_v3_ui <- renderUI({
  req(input$artist_v3)
  
  .tracks <- billboard %>% 
    filter(artist == input$artist_v3) %>% 
    pull(track) %>%
    unique()
  
  if (length(.tracks) == 1) {
    # If there's only one option, show a non-interactive text element with the 
    # track name
    return(
      # shiny provides 'wrapper' functions to create basic html elements. In this 
      # case, we use a div containing a label (less common or conflicting html tags
      # are accessible through the `tags` list) and a paragraph (`p`) element.
      # The paragraph has a grey text colour to visually clue the user in (even more)
      # that this value cannot be changed (it is 'disabled').
      # For more info on html elements or css styling, see your favourite search engine.
      div(
      tags$label("Selected track:"),
      p(.tracks, style = "color: darkgrey;")
    ))
  } else {
    # if we have multiple choices, we use the selectInput shiny widget. 
    # Note that the input we return is essentially identical to the input we 
    # used in the UI in the previous examples.
    return(selectInput("track_v3", label = "Choose a track...", choices = .tracks))
  }
})


# the plot is essentially identical, but note that we now use `selected_track()`
# instead of `input$track_v3` directly.
output$track_performance_v3 <- renderPlot({
  # only continue when a track is selected.
  req(selected_track())
  
  billboard_long %>% 
    filter(artist == input$artist_v3, track == selected_track()) %>% 
    ggplot(aes(x = week, y = rank, group = track)) +
    coord_cartesian(ylim = c(100, 1)) +
    geom_line()
})
```

The possibilities for nesting UI components are endless. Note however that with each additional layer of dynamism in the UI, the code gets exponentially more complex. In such cases, _modules_ might be more appropriate, but that is out of scope here. The previous example 
